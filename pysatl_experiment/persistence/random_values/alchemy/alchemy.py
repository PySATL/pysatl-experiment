from __future__ import annotations

import json
from typing import ClassVar

from sqlalchemy import Integer, String, UniqueConstraint
from sqlalchemy.orm import Mapped, mapped_column
from typing_extensions import override

from pysatl_experiment.persistence.db_store.base import ModelBase, SessionType
from pysatl_experiment.persistence.db_store.model import AbstractDbStore
from pysatl_experiment.persistence.model.random_values.random_values import (
    IRandomValuesStorage,
    RandomValuesAllModel,
    RandomValuesAllQuery,
    RandomValuesCountQuery,
    RandomValuesModel,
    RandomValuesQuery,
)


class AlchemyRandomValues(ModelBase):
    """
    SQLAlchemy ORM model representing stored random values generated by a
    specific random value generator with predefined parameters.

    Each row corresponds to a single generated sample identified by:
        - generator name,
        - generator parameters,
        - sample size,
        - sample number (sequence index of the sample).

    The uniqueness of this combination is enforced by the
    ``uq_random_values_unique`` constraint.

    Attributes:
        id (int): Primary key of the record.
        generator_name (str): Name of the generator used to produce the values.
            Typically corresponds to the generator class name.
        generator_parameters (str): JSON-encoded or serialized parameters
            passed to the generator.
        sample_size (int): Number of values generated in this sample.
        sample_num (int): Sequential number of the sample for the given generator
            and parameter set (e.g., 1st sample, 2nd sample, etc.).
        data (str): Serialized representation of the generated random values
            (e.g., JSON array).
    """

    __tablename__ = "random_values"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)  # type: ignore
    generator_name: Mapped[str] = mapped_column(String, nullable=False, index=True)  # type: ignore
    generator_parameters: Mapped[str] = mapped_column(String, nullable=False, index=True)  # type: ignore
    sample_size: Mapped[int] = mapped_column(Integer, nullable=False, index=True)  # type: ignore
    sample_num: Mapped[int] = mapped_column(Integer, nullable=False)  # type: ignore
    data: Mapped[str] = mapped_column(String, nullable=False)  # type: ignore

    __table_args__ = (
        UniqueConstraint(
            "generator_name",
            "generator_parameters",
            "sample_size",
            "sample_num",
            name="uq_random_values_unique",
        ),
    )


class AlchemyRandomValuesStorage(AbstractDbStore, IRandomValuesStorage):
    """
    SQLAlchemy-backed storage implementation for managing generated random
    values produced by various random value generators.

    This class provides CRUD operations for the ``AlchemyRandomValues`` model
    and implements the ``IRandomValuesStorage`` interface. It supports:

        • retrieving individual random value samples,
        • inserting or updating single samples,
        • deleting samples,
        • counting samples for the same generator configuration,
        • bulk insert of all samples for a generator configuration,
        • retrieving all samples in order,
        • retrieving only a limited number of samples.

    Stored random values are indexed by generator name, generator parameter
    set, sample size, and sample number. Generator parameters and data are
    serialized as JSON.

    The storage must be initialized via :meth:`init` before any database
    operations, otherwise a ``RuntimeError`` is raised.

    Attributes:
        session (SessionType): SQLAlchemy session configured by the parent
            ``AbstractDbStore`` class.
        _initialized (bool): Indicates whether the storage is ready for use.
    """

    session: ClassVar[SessionType]

    def __init__(self, db_url: str):
        """
        Initialize the storage provider with a database URL.

        Args:
            db_url (str): SQLAlchemy database connection URL.
        """
        super().__init__(db_url=db_url)
        self._initialized: bool = False

    @override
    def init(self) -> None:
        """
        Initialize the database engine and scoped session.

        Must be called before any storage operation.
        Sets the internal ``_initialized`` flag to ensure a session is available.
        """
        # Initialize engine and scoped session via AbstractDbStore
        super().init()
        self._initialized = True

    def _get_session(self) -> SessionType:
        """
        Return the active SQLAlchemy session.

        Raises:
            RuntimeError: If the storage has not been initialized.

        Returns:
            SessionType: SQLAlchemy session used for executing queries.
        """
        if not getattr(self, "_initialized", False):
            raise RuntimeError("Storage not initialized. Call init() first.")
        # Access class attribute defined by AbstractDbStore after init()
        return AlchemyRandomValuesStorage.session

    @override
    def get_data(self, query: RandomValuesQuery) -> RandomValuesModel | None:
        """
        Retrieve a single stored random value sample matching the query parameters.

        Args:
            query (RandomValuesQuery): Defines generator name, parameters,
                sample size, and sample number.

        Returns:
            RandomValuesModel | None:
                The matching record converted to a model, or ``None`` if no
                such sample exists.
        """
        params_json = json.dumps(query.generator_parameters)
        row: AlchemyRandomValues | None = (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
                AlchemyRandomValues.sample_num == int(query.sample_num),
            )
            .one_or_none()
        )
        if row is None:
            return None
        return RandomValuesModel(
            generator_name=query.generator_name,
            generator_parameters=query.generator_parameters,
            sample_size=query.sample_size,
            sample_num=query.sample_num,
            data=json.loads(row.data),
        )

    @override
    def insert_data(self, data: RandomValuesModel) -> None:
        """
        Insert a single sample of generated random values.

        If a sample with the same generator name, parameters, sample size,
        and sample number already exists, it is updated. Otherwise, a new row
        is inserted.

        Args:
            data (RandomValuesModel): Sample to insert or update.
        """
        params_json = json.dumps(data.generator_parameters)
        entity = AlchemyRandomValues(
            generator_name=data.generator_name,
            generator_parameters=params_json,
            sample_size=int(data.sample_size),
            sample_num=int(data.sample_num),
            data=json.dumps(data.data),
        )
        existing: AlchemyRandomValues | None = (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == entity.generator_name,
                AlchemyRandomValues.generator_parameters == entity.generator_parameters,
                AlchemyRandomValues.sample_size == entity.sample_size,
                AlchemyRandomValues.sample_num == entity.sample_num,
            )
            .one_or_none()
        )
        if existing is None:
            self._get_session().add(entity)
        else:
            existing.data = entity.data
        self._get_session().commit()

    @override
    def delete_data(self, query: RandomValuesQuery) -> None:
        """
        Delete a single random value sample matching the query parameters.

        Args:
            query (RandomValuesQuery): Identifying information of the sample to delete.
        """
        params_json = json.dumps(query.generator_parameters)
        (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
                AlchemyRandomValues.sample_num == int(query.sample_num),
            )
            .delete()
        )
        self._get_session().commit()

    @override
    def get_rvs_count(self, query: RandomValuesAllQuery) -> int:
        """
        Count how many samples exist for the given generator configuration.

        Args:
            query (RandomValuesAllQuery): Generator name, parameters, and sample size.

        Returns:
            int: Number of matching samples.
        """
        params_json = json.dumps(query.generator_parameters)
        return (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
            )
            .count()
        )

    @override
    def insert_all_data(self, query: RandomValuesAllModel) -> None:
        """
        Replace all samples for the given generator configuration.

        First deletes existing samples for the configuration, then inserts
        all samples from the provided list.

        Args:
            query (RandomValuesAllModel): Generator settings and full dataset.
        """
        params_json = json.dumps(query.generator_parameters)
        # delete existing
        (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
            )
            .delete()
        )
        # insert new
        for i, sample in enumerate(query.data, start=1):
            self._get_session().add(
                AlchemyRandomValues(
                    generator_name=query.generator_name,
                    generator_parameters=params_json,
                    sample_size=int(query.sample_size),
                    sample_num=i,
                    data=json.dumps(sample),
                )
            )
        self._get_session().commit()

    @override
    def get_all_data(self, query: RandomValuesAllQuery) -> list[RandomValuesModel] | None:
        """
        Retrieve all samples for the given generator configuration, ordered by sample number.

        Args:
            query (RandomValuesAllQuery): Generator name, parameters, and sample size.

        Returns:
            list[RandomValuesModel] | None:
                List of samples in numeric order.
        """
        params_json = json.dumps(query.generator_parameters)
        rows: list[AlchemyRandomValues] = (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
            )
            .order_by(AlchemyRandomValues.sample_num)
            .all()
        )
        return [
            RandomValuesModel(
                generator_name=query.generator_name,
                generator_parameters=query.generator_parameters,
                sample_size=query.sample_size,
                sample_num=row.sample_num,
                data=json.loads(row.data),
            )
            for row in rows
        ]

    @override
    def delete_all_data(self, query: RandomValuesAllQuery) -> None:
        """
        Delete all stored samples for the specified generator configuration.

        Args:
            query (RandomValuesAllQuery): Identifies which entries to remove.
        """

        params_json = json.dumps(query.generator_parameters)
        (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
            )
            .delete()
        )
        self._get_session().commit()

    @override
    def get_count_data(self, query: RandomValuesCountQuery) -> list[RandomValuesModel] | None:
        """
        Retrieve up to ``query.count`` samples for the given generator configuration.

        Args:
            query (RandomValuesCountQuery): Generator settings and number of samples to return.

        Returns:
            list[RandomValuesModel] | None:
                List of up to ``count`` samples, ordered by sample number.
        """
        params_json = json.dumps(query.generator_parameters)
        rows: list[AlchemyRandomValues] = (
            self._get_session()
            .query(AlchemyRandomValues)
            .filter(
                AlchemyRandomValues.generator_name == query.generator_name,
                AlchemyRandomValues.generator_parameters == params_json,
                AlchemyRandomValues.sample_size == int(query.sample_size),
            )
            .order_by(AlchemyRandomValues.sample_num)
            .limit(int(query.count))
            .all()
        )
        return [
            RandomValuesModel(
                generator_name=query.generator_name,
                generator_parameters=query.generator_parameters,
                sample_size=query.sample_size,
                sample_num=row.sample_num,
                data=json.loads(row.data),
            )
            for row in rows
        ]
